use crate::usda::token::Token;

/// Represents USD data types for parsing.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Type {
    Bool,
    BoolVec,
    Uchar,
    UcharVec,
    Int,
    Int2,
    Int3,
    Int4,
    IntVec,
    Int2Vec,
    Int3Vec,
    Int4Vec,
    Uint,
    Int64,
    Int64Vec,
    Uint64,
    Half,
    Half2,
    Half3,
    Half4,
    HalfVec,
    Half2Vec,
    Half3Vec,
    Half4Vec,
    Float,
    Float2,
    Float3,
    Float4,
    FloatVec,
    Float2Vec,
    Float3Vec,
    Float4Vec,
    Double,
    Double2,
    Double3,
    Double4,
    DoubleVec,
    Double2Vec,
    Double3Vec,
    Double4Vec,
    Quath,
    Quatf,
    Quatd,
    QuathVec,
    QuatfVec,
    QuatdVec,
    String,
    Token,
    Asset,
    StringVec,
    TokenVec,
    AssetVec,
    Matrix2d,
    Matrix3d,
    Matrix4d,
    Dictionary,
}

/// Maps a Token keyword to its string representation.
pub fn keyword_lexeme(token: &Token<'_>) -> Option<&'static str> {
    match token {
        Token::Add => Some("add"),
        Token::Append => Some("append"),
        Token::Class => Some("class"),
        Token::Config => Some("config"),
        Token::Connect => Some("connect"),
        Token::Custom => Some("custom"),
        Token::CustomData => Some("customData"),
        Token::Default => Some("default"),
        Token::Def => Some("def"),
        Token::Delete => Some("delete"),
        Token::Dictionary => Some("dictionary"),
        Token::DisplayUnit => Some("displayUnit"),
        Token::Doc => Some("doc"),
        Token::Inf => Some("inf"),
        Token::Inherits => Some("inherits"),
        Token::Kind => Some("kind"),
        Token::NameChildren => Some("nameChildren"),
        Token::None => Some("None"),
        Token::Offset => Some("offset"),
        Token::Over => Some("over"),
        Token::Payload => Some("payload"),
        Token::Permission => Some("permission"),
        Token::PrefixSubstitutions => Some("prefixSubstitutions"),
        Token::Prepend => Some("prepend"),
        Token::Properties => Some("properties"),
        Token::References => Some("references"),
        Token::Relocates => Some("relocates"),
        Token::Rel => Some("rel"),
        Token::Reorder => Some("reorder"),
        Token::RootPrims => Some("rootPrims"),
        Token::Scale => Some("scale"),
        Token::SubLayers => Some("subLayers"),
        Token::SuffixSubstitutions => Some("suffixSubstitutions"),
        Token::Specializes => Some("specializes"),
        Token::SymmetryArguments => Some("symmetryArguments"),
        Token::SymmetryFunction => Some("symmetryFunction"),
        Token::TimeSamples => Some("timeSamples"),
        Token::Uniform => Some("uniform"),
        Token::VariantSet => Some("variantSet"),
        Token::VariantSets => Some("variantSets"),
        Token::Variants => Some("variants"),
        Token::Varying => Some("varying"),
        _ => None,
    }
}
